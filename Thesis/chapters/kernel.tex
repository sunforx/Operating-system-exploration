\chapter{编写操作系统内核}

从内存管理，输入输出，多进程，分时四个模块丰富操作系统的内容

\section{内存管理}

内存 (RAM) 是计算机中不可缺少的重要硬件，所有程序的运行都是在内存中进行的，
而CPU访问硬盘数据也必须先经过内存交换才得以实现，内存在加速CPU访问硬盘居功至伟。
由内存的重要性可知内存管理在操作系统中也非常重要。	

内存的结构通常用地址和空间表示，在计算机运行过程中，
内存的分配是随机的，导致内存的释放也是相对无序的，这样导致了很多的碎片化问题，
也就是随计算机运行时间变长，内存中到处遍布小块零散空闲空间，虽然零散空间总数很大，
但很难满足新进程序的内存需求，于是内存管理显得十分必要。

内存管理设计的主要目的是快速并且高效的分配内存空间，并在适当的时间释放并回收内存空间。
根据内存管理的设计目的。

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=137, lastline=143,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \caption{数据结构-内存管理}
  \label{lst:mem}
\end{listing}

\begin{description}
\item[frees:]当前可用内存组数
\item[maxfrees:]可用内存组数的最大值
\item[lostsize:]释放失败的内存的大小总和
\item[losts:]释放失败次数
\end{description}

经过内存初始化和释放所有内存空间后，内存管理正常运行。

\subsection{内存分配}

内存的分配方式涉及到内存释放，好的分配方式会使得内存使用的效率大大提高。
根据内存的大小来划分内存如何使用，预计使用32KB用于内存分配的管理空间，
则共有4000组左右的内存用于分配给各个程序使用，每个组4KB。

每一组内存经过初始化都拥有自己的数据结构，
即每一组空闲内存的地址和大小都被记录到空闲内存表free。

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|}
    \hline 组号 & 地址 \\
    \hline 2 & 0x00005000 \\ 
    \hline 1 & 0x00004000 \\
    \hline 0 & 0x00003000 \\
    \hline
  \end{tabular}
  \caption{空闲内存表free}
  \label{tab:free}
\end{table}

一旦系统接收到程序申请内存的请求（需求的内存大小），
就开始在内存中寻找足够大的内存完成这次申请，并返回可供使用的空闲内存的地址。
完成申请后系统需要重新整理空闲内存表free，将可用内存组数减一，
将返回给程序空闲空间大小根据程序需求进行调整，并对剩余的可用内存表进行按地址升序整理。
流程图见\ref{fig:memman}，程序见~\ref{lst:alloc}。

% ----------------------------

\subsection{内存释放}

为保证磁盘空闲空间尽可能少的碎片化，内存释放首先考虑的是使待释放空间与附近空闲空间进行合并。

具体分为三种情况：

\begin{description}
\item[前端空闲:]释放内存的相连前端是空闲内存或释放内存相连两端都是空闲内存
\item[后端可用:]释放内存的相连后端是空闲空间
\item[前端后端均不可用:]在当前位置释放内存
\end{description}

已知：待释放的空间的地址和空间大小

根据空闲内存表free的编号从0到frees遍历查找地址大于待释放空间的空闲内存，
并根据得到的空闲内存编号i及大小size区分此时的待释放内存应当采取何种方式释放，程序参见~\ref{lst:rw}。

前端空闲：

当相连前端有可用内存时将可释放内存大小归入前端可用内存内，frees不变;

当相连后端也有可用内存时将后端内存大小归入前端可用内存内，frees减一。

内存释放前后情况如图~\ref{fig:mem0}和图~\ref{fig:mem1}所示，程序见~\ref{lst:mem1}: 

\begin{figure}[h]
  \centering
  \includegraphics[width=.7\textwidth]{fig/mem0.pdf}
  \caption{前端空闲}
  \label{fig:mem0}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=.7\textwidth]{fig/mem1.pdf}
  \caption{前端可用，且后端空闲}
  \label{fig:mem1}
\end{figure}

% ------------------------------

\newpage
后端空闲:

当相连后端有可用内存的时候将free[i]的地址换为待释放内存的地址，相连后端内存大小归入待释放内存大小，frees不变。

内存释放前后情况如图~\ref{fig:mem2}所示，程序见~\ref{lst:mem2}。

\begin{figure}[h]
  \centering
  \includegraphics[width=.7\textwidth]{fig/mem2.pdf}
  \caption{后端空闲}
  \label{fig:mem2}
\end{figure}

% -----------------------------

前端后端均被占用:

由于被释放空间周围没有空闲内存，为保证free内各段内存仍然按照内存地址升序排列，
使空闲空间计数最大值加一，free[i]后续空闲内存序号加一，并将释放空间组号定为i。

内存释放前后情况如图~\ref{fig:mem3}所示，程序如~\ref{lst:mem3}。
\begin{figure}[h]
  \centering
  \includegraphics[width=.7\textwidth]{fig/mem3.pdf}
  \caption{前端后端均被占用}
  \label{fig:mem3}
\end{figure}

\section{输入输出}

输入作为人与计算机之间最基本的交互方式，其中键盘和鼠标是标准输入设备。

CPU通过PIC\footnote{PIC通过中断控制请求使用CPU，即在需要的时候对CPU发出中断请求，暂停CPU现在运行的作业，先完成中断请求再继续之前的作业}
（Programmable interrupt controller）与外部设备进行数据交换。
键盘作为计算机最早的外设，位于主PIC的IRQ1;
而鼠标作为第四代计算机才出现的输入设备，位于从PIC的IRQ12，而从PIC连接在主PIC的IRQ2。

输入设备输入时是将一个个指令\footnote{每一次敲击键盘按键，移动鼠标，点击鼠标都会产生响应的指令}
发送到CPU，而CPU同时只能处理一个指令（虽然处理时间非常短），
所以需要一个缓冲区fifo\footnote{缓冲区fifo采用先入先出的数据结构，使得先传入的输入指令能够率先得到执行}来接收输入数据。

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=40, lastline=44,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \caption{数据结构-缓冲区fifo}
  \label{lst:fifo}
\end{listing}
\begin{description}
\item[*buf:]缓冲区在内存中的地址;
\item[p, q:]下一个写入地址，下一个数据读入地址;
\item[size, free:]缓冲区大小，空闲空间大小;
\item[TASK flags:]溢出标记（-1和0分别表示有溢出和无溢出）;
\item[TASK *task:]在当前位置释放内存。
\end{description}

操作系统运行后始终通过函数fifo32\_status(\&fifo)\footnote{存储总量=size-free}
监测fifo缓冲区内是否有数据，如果有数据才执行下一步对输入指令的响应。
接收输入信号的函数fifo32\_get(\&fifo)负责从缓冲区fifo中取出一个数据（键盘为1个字节，鼠标为4个字节）交由CPU处理。
流程图见\ref{fig:fifo},程序见\ref{lst:kbd}.

计算机收到数据后根据数据的大小区间区分这一段数据是何处传来的并进行相应处理。
一旦收到的指令为256到511，系统判定为键盘输入;
当指令为512到767，系统判定为鼠标输入。

% --------------------

\subsection{键盘输入}

键盘作为最基础也是大众使用最精确的输入设备，它负担着很多的责任：
\begin{enumerate}
\item 输入文本按键
\item 修改文本输入的基本指令按键
\item 修改计算机的状态特殊按键
\end{enumerate}

按下不同的功能按键，键盘向计算机发送的指令是不一样的。

若输入指令为256-0x80+256时，为输入文本指令;

输入指令为退格键，回车键;

修改计算机的状态特殊按键如下:
\begin{table}[!ht]
  \centering
  \begin{tabular}{|l|c|l|c|}
    \hline 功能 & 指令 & 功能 & 指令 \\
    \hline 左Shift & 256+0x2a & CapsLock & 256+0x3a \\ 
    \hline 右Shift & 256+0x36 & NumLock off & 256+0xaa \\
    \hline 左Shift off & 256+0xaa & ScrollLock & 256+0xaa \\
    \hline 右Shift off & 256+0xb6 & & \\
    \hline
  \end{tabular}
  \caption{修改状态的特殊指令}
  \label{tab:hello}
\end{table}

% ---------------------

\subsection{鼠标输入}

鼠标作为第四代计算机才出现的输入设备，因为涉及到坐标位置的变化，它的输入指令较键盘也相对复杂，
从鼠标传到计算机的信号都是4个字节一组的，其中第一个字节表示状态，其他3个有效指令分别为x坐标，y坐标以及鼠标按键状态。

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=126, lastline=129,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \caption{数据结构-鼠标输入的数据}
  \label{lst:mouse_data}
\end{listing}
\begin{description}
\item[buf:]存放鼠标一个数据指令的数组;
\item[phase:]当前鼠标工作的阶段;
\item[x, y]缓冲区大小，空闲空间大小;
\item[btn]按键状态。
\end{description}

% ----------------------

\subsection{标准输出}

由于是面对硬件开发操作系统，无法使用各种成熟的库和函数，
所以输出也只能从修改VRAM的一个个像素开始。

流程如下：
通过一系列指令后，系统需要向屏幕打印字符，
则从数组中读取一个数据，并从字体库（包含基本字体的像素化数组）中找到对应的显示方法，
写入VRAM（Video RAM），在屏幕对应坐标范围内显示数据，
循环读取下一个并显示下一个数据。

\section{多道程序系统与分时操作系统}

\subsection{多道程序系统}

现代的计算机已经不仅仅作为数字计算的工具，进入大众生活的计算机被赋予了更多生活上的需求，
用户可能在看电影的同时查看电子邮件，也有可能在写论文的时候进入浏览器查询相关资料，
但是更重要的是计算机往往在用户不经意间打开防病毒软件等保证用户计算机的安全。

由此可见多进程的工作方式在计算机工作中不可缺少。

但是在实际的处理过程中，计算机并不能同时处理多个程序。

首先要处理的问题是如何运行多个程序，早期的多道程序设计的出发点是充分的利用CPU，
作为输入设备的打孔纸带与CPU速度相比差距过大，昂贵的CPU常常在等待I/O信号而闲置。

具体情形如：A作业等待磁盘或者其他I/O时，CPU暂停为A作业服务，而转向为已完成I/O操作的B作业服务，
等到B需要执行下一步I/O操作时，CPU发现A作业完成了I/O操作，又转向为A作业服务，依次循环直到队列中所有作业完成。

由于A作业和B作业并行存储在计算机内存中，虽然在具体的执行中多次交换先后顺序执行，
但两个作业输出在同一个磁盘，故认为是多道程序在计算机中运行。

\subsection{分时操作系统}

分时是使得在用户看来计算机的多道程序同时运行，但是同时运行这也是不可能的。

所以只能采取折中的办法，使得CPU在用户不能明显感觉到的时间间隔内切换运行多个程序，
在切换后每个程序都能对作业进行一定的处理，在进行多个周期后，各个程序先后完成作业。

“不能明显感觉到的时间间隔内切换”中有两个概念，时间间隔和切换：

\begin{enumerate}
\item 时间间隔太长则用户会有明显的卡顿感，不利于分时概念的实现，
  而时间间隔太短则时间不足以让程序响应并完成一定量的工作，同样不利于分时概念的实现。
\item 切换涉及到保存当前程序的运行状态以便于程序获得CPU时间后可以接续上次的任务继续执行。
\end{enumerate}

\subsection{定时器}

定时器的实现是实现分时操作系统的关键，定时器每隔一段时间就向CPU发送中断信号，并记录发送的次数，以定时器发送的中断次数作为定时的依据。

管理定时器主要是使用PIT\footnote{PIT连接IRQ0，设定PIT就可以设定IRQ0的中断间隔，中断频率=单位时间事钟周期书（主频）/设定的数值}
（Programmable Interval Timer），之前说到定时器时间太短不利于分时的实现，故暂定1秒中发生100次中断。

在实际的运用中，往往需要用到不止一个定时器，于是需要对多个定时器进行管理，数据结构如下：

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=175, lastline=187,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \caption{数据结构-多定时器}
  \label{lst:multi_timer}
\end{listing}

\begin{description}
\item[Timer *next:]下一个定时器地址;
\item[timeout:]下一个超时时刻;
\item[flags, flags2:]各个定时器的状态，在应用程序结束时定时器是否取消的标记
\item[count, next:]当前时刻，下一个时刻;
\item[Timer *t0:]所有时刻都要减去这个值。
\end{description}

对每个定时任务设置到超时时刻（对每个任务的运行时间进行计量，超过指定时刻向系统发送指令），
这样可以对一些设定了定时的任务在时间到了之后执行指定操作，
如光标的闪烁，页面的刷新等。

\subsection{任务切换}

在多道程序系统和分时操作系统分时操作系统完成后，任务切换就可以进行了。

任务切换从字面上理解很简单，多个任务之间来回切换，但是任务切换在计算机中实现却不那么简单。

如现有A和B两个任务，A正在运行，现在需要切换到B，流程如下：
\begin{enumerate}
\item 任务B向CPU发送切换任务的指令
\item CPU把当前寄存器中的值全部写到内存中
\item CPU执行任务B
\item CPU切换到任务A并把所有寄存器中的值从内存中读出来，继续执行任务A
\end{enumerate}
为了实现复杂的任务管理，需要用到的数据结构如下：
\begin{listing}[H]
  \inputminted[tabsize=2, firstline=227, lastline=232,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \inputminted[tabsize=2, firstline=222, lastline=226,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \inputminted[tabsize=2, firstline=209, lastline=221,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \caption{数据结构-多任务}
  \label{lst:multi_task}
\end{listing}

\subsection{任务优先级}

在实际的运用中，所有任务在同一个优先级的安排显然是不合理的，
比如系统在执行A作业时，由于A作业和键盘输入作业优先级相同，
所以系统可能认为应该先完成A作业再执行键盘输入。

而通常人为操作中键盘优先级应该是最高的，为此设计任务的优先级。

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=222, lastline=226,
    linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
  \caption{数据结构-任务优先级}
  \label{lst:task_level}
\end{listing}

设计中，将任务分为多个层次，将音乐、网络传输等对优先级要求高的任务放在最高的优先级，
将鼠标等任务放在稍低的优先级，将对优先级要求低的任务放在较低的优先级。

则系统在多任务同时运行的情况下会优先处理高优先级的任务，处理完成后处理稍低的优先级任务，
优先级较低的任务将在系统较空闲（即无更高优先级任务）的时候处理。

% % memory
% \include{chapters/sections/memory}
% % io
% \include{chapters/sections/io}
% % multi
% \include{chapters/sections/multi}
