\chapter{编写操作系统内核}

从内存管理，输入输出，多进程，分时四个模块丰富操作系统的内容

\section{内存管理}

内存 (RAM) 是计算机中不可缺少的重要硬件，所有程序的运行都是在内存中进行的，
而CPU访问硬盘数据也必须先经过内存交换才得以实现，内存在加速CPU访问硬盘居功至伟。
由内存的重要性可知内存管理在操作系统中也非常重要。	

内存的结构通常用地址和空间表示，在计算机运行过程中，
内存的分配是随机的，导致内存的释放也是相对无序的，这样导致了很多的碎片化问题，
也就是随计算机运行时间变长，内存中到处遍布小块零散空闲空间，虽然零散空间总数很大，
但很难满足新进程序的内存需求，于是内存管理显得十分必要。

内存管理设计的主要目的是快速并且高效的分配内存空间，并在适当的时间释放并回收内存空间。
根据内存管理的设计目的，内存管理的数据结构如下:

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=137, lastline=143,
  linenos=true]{c}{../ZOS/src/kernel/bootpack.h}
\end{listing}

\begin{description}
\item[frees:]空闲空间数量
\item[maxfrees:]用于观察可用状况：frees的最大值
\item[lostsize:]释放失败的内存的大小总和
\item[losts:]释放失败次数
\end{description}

经过内存初始化和释放所有内存空间后，内存管理正常运行。

\newpage
\subsection{内存分配}

内存的分配方式与之后的内存释放息息相关，好的分配方式会使得效率大大提高。
根据内存的大小来划分内存如何使用，预计使用32KB用于内存分配的管理空间，
则共有4000组左右的内存用于分配给各个程序使用。

每一组内存经过初始化都拥有自己的数据结构，
即每一组空闲内存的地址和大小都被记录到空闲内存表free。

\begin{table}[!ht]
  \centering
  \begin{tabular}{|c{4cm}|c{8cm}|}
    \hline 
    组号 & 地址 \\
    \hline 
    1 & 0x00003000 \\ 
    \hline 
    2 & 0x00004000 \\
    \hline 
    3 & 0x00005000 \\
    \hline
  \end{tabular}
  \caption{表格示例}
  \label{tab:hello}
\end{table}

一旦系统接收到程序申请内存的请求（需求的内存大小），
就开始在内存中寻找足够大的内存完成这次申请，并返回可供使用的空闲内存的地址。
完成申请后系统需要重新整理空闲内存表free，将最大可用内存组数减一，
将返回给程序空闲空间大小根据程序需求进行调整，并对剩余的可用内存表进行整理。

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=68, lastline=78,
  linenos=true]{c}{../ZOS/src/kernel/memory.c}
\end{listing}

\newpage
\subsection{内存释放}

为保证磁盘空闲空间尽可能少的碎片化，内存释放首先考虑的是与附近空闲空间进行合并。

具体分为三种情况：

\begin{description}
\item[前端空闲:]释放内存的相连前端是空闲内存或释放内存相连两端都是空闲内存
\item[后端可用:]释放内存的相连后端是空闲空间
\item[前端后端均不可用:]挪动空闲空间以合并
\end{description}

已知：待释放的空间的地址和空间大小

根据空闲内存表free的编号查找地址大于待释放空间的空闲内存，
并根据得到的空闲空间编号及大小区分此时的待释放内存应当采取何种方式释放。
\begin{listing}[H]
  \inputminted[tabsize=2, firstline=91, lastline=95,
  linenos=true]{c}{../ZOS/src/kernel/memory.c}
\end{listing}

\newpage
前端空闲：

当待释放的空间前方有空闲空间时，将free[i-1]的大小加上释放空间的大小

内存释放前后情况如图\ref{fig:mem0}和图\ref{fig:mem1}所示: 

\begin{figure}[h]
  \centering
  \includegraphics[width=.8\textwidth]{fig/mem0.pdf}
  \caption{前端空闲}
  \label{fig:mem0}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=.8\textwidth]{fig/mem1.pdf}
  \caption{前端可用，且后端空闲}
  \label{fig:mem1}
\end{figure}

\newpage
实现如下：

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=98, lastline=116,
  linenos=true]{c}{../ZOS/src/kernel/memory.c}
\end{listing}

\newpage
后端空闲:

\begin{figure}[h]
  \centering
  \includegraphics[width=.8\textwidth]{fig/mem2.pdf}
  \caption{后端空闲}
  \label{fig:mem3}
\end{figure}

实现如下：

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=118, lastline=127,
  linenos=true]{c}{../ZOS/src/kernel/memory.c}
\end{listing}

\newpage
前端后端均被占用:

由于被释放空间周围没有空闲内存，为保证free内各段内存仍然按照内存地址升序排列，
使空闲空间计数最大值加一，free[i]后续空闲内存序号加一，并将释放空间序号定为i。
\begin{figure}[h]
  \centering
  \includegraphics[width=.8\textwidth]{fig/mem3.pdf}
  \caption{前端后端均被占用}
  \label{fig:mem4}
\end{figure}

实现如下：
\begin{listing}[H]
  \inputminted[tabsize=2, firstline=128, lastline=141,
  linenos=true]{c}{../ZOS/src/kernel/memory.c}
\end{listing}
\newpage
\section{输入输出}

输入作为人与计算机之间最基本的交互方式，其中键盘和鼠标作为标准输入设备。

\begin{listing}[H]
  \inputminted[tabsize=2, firstline=151, lastline=151,
  linenos=true]{c}{../ZOS/src/kernel/bootpack.c}
\end{listing}


\newpage
\subsection{键盘输入}
当输入为256到511，系统判定为键盘输入。
\begin{listing}[H]
  \inputminted[tabsize=2, firstline=161, lastline=161,
  linenos=true]{c}{../ZOS/src/kernel/bootpack.c}
\end{listing}
键盘输入分为字母输入，常规按键，特殊按键


\newpage
\subsection{鼠标输入}
当输入为512到767，系统判定为鼠标输入。
\begin{listing}[H]
  \inputminted[tabsize=2, firstline=247, lastline=247,
  linenos=true]{c}{../ZOS/src/kernel/bootpack.c}
\end{listing}

\newpage
\subsection{标准输出}

\newpage
\section{多道程序系统}

现代的计算机已经不仅仅作为数字计算的工具，而进入大众生活的计算机被赋予了更多的生活需求，
用户可能在看电影的同时查看电子邮件，也有可能在写论文的时候进入浏览器查询相关资料，
但是更重要的是计算机往往在用户不经意间打开防病毒软件等保证用户计算机的安全\cite{tanenbaum2009modern}。

由此可见多进程的工作方式在计算机工作中同样不可或缺。

但是在实际的处理过程中，计算机并不能同时处理多个程序，所以必须采用分时的设计，
关于分时操作系统的设计在下一节。
在此有两个概念，同时处理和多个程序，同时处理属于分时，多道程序属于多道程序设计。

首先要处理的问题是如何在运行多个程序，。

\newpage
\section{分时操作系统}

在上一节中说到分时是使得在用户看来计算机的多道程序同时运行，多道程序已经实现了，
分时简单说是使得CPU在用户不能明显感觉到的时间间隔内切换运行多个程序，在切换的过程中...
